""" ლისტის ჩაშენებული ფუნქციები """

""" in-ით ჩვენ შეგვიძლია გავიგოთ არის თუ არა კონკრეტული ელემენტი ცოლექციაში """
vehiclet = ["banana","apple","melon"]
print("melon" in vehiclet)

""" sort() ფუნქცია დაალაგებს რიცხვების სიას ზრდადობით """
numbers = [7, 15, 12, 18, 22]
numbers.sort() 

""" len - ფუნქციით ჩვენ ვითვლით სიაში არსებული ელემენტების რაოდენობას """
names = ["rati","luka","gio","nugo"]
print(len(names))

""" append - ფუნქციით ჩვენ სიის ბოლო ადგილზე ვამატებთ ელემენტს """
nums = [1,2,3,4]
nums.append(5)
print(nums)

""" insert - ფუნქციით ჩვენ ჩვენთვის სასურველ ინდექსზე (რასაც არგუმენტად ვწერთ),
 ვამატებთ ჩვენთვის სასურველ ელემენტს """
nums.insert(1, 1.5)
print(nums)

""" pop - ფუნქციით ჩვენ ვშლით ჩვენთვის სასურველ ელემენტს სიიდან ატრიბუტად 
 სასურველი ელემენტის ინდექსის დაწერით """
nums.pop(1)
print(nums)

""" sum() ფუნქცია არგუმენტად იღებს სიას და კრიბავს ყველა ელემენტს სიაში. 
 sum ფუნქციას შეუძლია იმუშაოს მხოლოდ რიცხვითი მნიშვნელობების მქონე სიებთან. """
total = sum(nums)
print(total)

""" max() ფუნქცია აბრუნებს სიაში არსებულ მაქსიმალურ მნიშვნელობას. """
max_value = max(nums)
print(max_value)

""" min() ფუნქცია აბრუნებს მინიმალურ მნიშვნელობას სიაში. """
min_value = min(nums)
print(min_value)

""" sorted() ფუნქცია ალაგებს სიაში არსებულ ელემენტებს რიგის მიხედვით ისე რომ სიას არ ცვლის. 
 sorted() ფუნქციას შეუძლია გაუმკლავდეს როგორც ციფრულ, ასევე ტექსტურ მნიშვნელობებს. 
 ტექსტური მნიშვნელობებისთვის ის ალაგებს მათ ანბანურად. 
 reverse არგუმენტის გამოყენებით შეგიძლიათ მიუთითოთ ზრდადი ან კლებადი რიგი. 
 როდესაც reverse = True, მნიშვნელობები დალაგებულია კლებადობით."""
new_list = sorted(nums, reverse = True)
print(new_list)

 
""" ლისტებისა და სტრინგების გარდა პითონში კიდევ მრავალი კლექციააა.
 ერთე-ერთი მათგანია ტუპლი(tuple) """

""" ტუპლები სიების მსგავსად სხვადასხვა მონაცემთა ერთობლიობაა რომელიც იქმნება ფრჩხილების() გამოყენებით """
date = (21, "May", 2004, 21)
""" ტუპლებში ელემენტებს თავიანთი ინდექსები აქვთ, რომელიც იწყება 0 დან. 
 ტუპლებში ელემენტებზე ინდექსების შაშუალებით წვდომა შეგვიძლია ისე როგორც ამას სიებში და სტრინგებში ვაკეთებდით. 
  ტუპლები და სიები ერთმნეთსიგან იმით განსხვავდებიან რომ ტუპლები შეუცვლელი კოლექციაბია მსგავსად სტრინგებისა """
print(date[1])

""" count ფუნქცია ითვლის თუ რამდენჯერ გვაქვს სიაში არგუმენტად მოცემული ელემენტი """
print(date.count(21))

""" ტუპლებზე ჩვენ შეგვიძლია მრავალი სიაზე არსებული ფუნქცია გამოვიყენოთ მაგალითად len(), max(), min(),  
 ტუპლებზე ჩვეულებრივ შეგვიძლია პირობითი ოპერატორების, ციკლების გამოყენება. 
 ჩვენ შევიძლია ტუპლის ელემენტების ცვლადებში შენახვა შემდეგნაირად: """
day, month, year, num1 = date
print(day)
print(month)
print(year)
print(num1)

""" * ატრიბუტით ჩვენ შეგვიძლია ცვლადში რამოდენიმე ელემენტის შენახვა.
 იგი ჩვენ გამოგვადგეა უცნობი სიგრძის ტუპლებთან ურთიერთობისას. """
num = (1, 2, 3, 4, 5, 6, 7, 8)
n1, *rest_n = num
print(n1)
print(rest_n)

""" sets, სიებისა და ტუპლებისგან განსხვავებით, დაულაგებელი კოლექციებია. ისინი იქმნება ხვეული ფრჩხილებით { }. 
 set-ში არ დაიშვება ერთნაირი ელემენტები, თუმცა მაინც დამატების მიუხედავად პროგრამა ერორს არ ამოაგდებს. 
 განმეორებული ელემენტი უბრალოდ იგნორირებული იქნება პროგრამის მიერ. 
 set ცვალებადია, რაც იმას ნიშნავს, რომ თქვენ შეგიძლიათ დაამატოთ ან წაშალოთ ელემენტი მისგან.
 გამოიყენეთ add() და remove() ფუნქციები, თითოეულს აქვს მნიშვნელობა, როგორც არგუმენტი, რომ დაამატოთ ან წაშალოთ იგი set-დან.
 clear() ფუნქცია არ იღებს არგუმენტს და შლის ყველა ელემენტს set-დან. 
 union() ფუნქცია გამოიყენება ორი სეტის გასაერთიანებლად.
 difference() ფუნქცია აბრუნებს ისეთ ელემენტს(ელემენტებს) რომელიც გვხვდება მხოლოდ პირველ სეტში და არ გვხვდება მეორე სეტში"""

students = {'Amanda', 'Robert', 'Alice'}
students.add('John')
students.remove('Amanda')
students.clear()
set1 = {'pen', 'book', 'pencil'}
set2 = {'eraser', 'book'}
combined = set1.union(set2)

""" კოლექციის ტიპი, Dictionaries, პრიდაპირ რომ გადავთარგმნოთ ითარგმნება როგორც ლექსიკონი და ზუსტად ლექსიკონის მაგვარი რამაა.
 მასში არსებული ელემენტები სახელი:მნიშვნელობის ტიპშია წარმოდგენილი. dictionaries იქმნება დაკლაკნული ფრჩხილების { } საშუალებით. """
contact ={
"name": "John",
"number": 111222333
}

""" სახელი:მნიშვნელობის(key:value) წყვილები ერთმანეთისგან მძიმეებითაა გამოყოფილი. """

vehicle = {
  "brand": "Audi",
  "model": "Q5",
}
"""
dictionary name:vehicle
keys: "brand" ,"model"
values: "Audi","Q5"
"""

""" სახელი:მნიშვნელობის წყვილში სახელი ყოველთვის უნდა იყოს უცვლელი მონაცემთა ტიპი, ხოლო მნიშვნელობა ნებისსმიერი მონაცემთა ტიპის. 
 dictionaries-ში წყვილებს შეიძლება ჰქონდეთ ერთნაირი მნიშვნელობები მაგრამ მხოლოდ განსხვავებული სახელები.
 ლექსიკონებში მნიშვნელობებზე წვდომისთვის საჭიროა სახელების გამოყენება ანუ ჩვენ ლექსიკონებში ინდეხების მაგივრად ვიყენებთ სახელებს."""
 
print(vehicle["brand"])
 
""" ლექსიკონში მნიშვნელობებზე წვდომის კიდევ ერთი გზა არის get() ფუნქცია. """
print(vehicle.get("brand"))

""" თქვენ შეგიძლიათ მიიღოთ ლექსიკონის ყველა მნიშვნელობა და სახელი, შესაბამისად values() და keys() ფუნქციების გამოყენებით. """
print(vehicle.keys())
print(vehicle.values())

""" items() ფუნქცია აბრუნებს ლექსიკონში არსებულ ყველა წყვილს. """
print(vehicle.items())

""" თქვენ შეგიძლიათ გამოიყენოთ სახელები არა მხოლოდ ლექსიკონში მნიშვნელობებზე წვდომისთვის, არამედ მათი შესაცვლელად. """
vehicle["brand"] = "BMW"
print(vehicle["brand"])

""" თქვენ შეგიძლიათ დაამატოთ ახალი ელემენტი ახალი სახელის მიწოდებით და მისთვის მნიშვნელობის მინიჭებით. """
vehicle["power"] = 5.0
print(vehicle)

""" update() ფუნქცია ანახლებს სიას მოცემული არგუმენტის მიხედვით. თუ გადაცემული სახელი მოცემული გვაქვს ლექსიკონში მაშინ ცვლის მნიშვნელობას,
 ხოლო თუ არ არის მოცემული ლექსიკონში მაშინ ამატებს. ჩვენ შეგვიძლია მრავალი არგუმენტი მივანიჭოთ update() ფუნქციას."""
vehicle.update({"brand":"Audi"})
print(vehicle)
vehicle.update({"new brand":"BMW"})
print(vehicle)

""" pop() ფუნქცია შლის ელემენტს მითითებული სახელით. ის არგუმენტად იღებს იმ ელემენტის სახელს, რომლის ამოღებაც გსურთ. """
vehicle.pop("new brand")
print(vehicle)

""" შეგიძლიათ გამოიყენოთ in ოპერატორი, რათა შეამოწმოთ არის თუ არა სახელი ან მნიშვნელობა ლექსიკონში. """
print("brand" in vehicle)
print("Audi" in vehicle.values())

""" ჩვენ შეგვიძლია for loop - ით გადავუაროთ ლექსიკონს. საიტერაციო ცვლადი მნიშვნელობად ლექსიკონში არსებულ სახლებს მიიღებს. 
 იმისთვის რომ საიტერაციო ცვლადმა მნიშვნელოად ლექსიკონის მნიშვნელობები მიიღოს დაგვჭირდება values() ფუნქცია"""
for i in vehicle:
    print(i)

for i in vehicle.values():
    print(i)


""" ჩვენ შეგვიძლია სიის შედარებით მარტივი და წაკითხვადი გზით შექმნა """
nums1 = [x for x in range(10)]
print(nums1)


""" <variable> = <expression> for <item> in <iterable>:"""
#variable - აქ ინახება სია
#expression - დამატებითი ფუნქცია
#item - საიტერაციო ცვლადი
#iterable - საიტერაციო

"""თქვენ შეგიძლიათ გამოიყენოთ ნებისმიერი გამონათქვამი სიის თითოეულ ელემენტზე, რომელიც იქმნება სიის გაგებით.
 მაგალითად, შემდეგი კოდი აორმაგებს თითოეულ მნიშვნელობას დიაპაზონში(10) და ინახავს შედეგებს სიაში: """
nums = [x*2 for x in range(10)]

""" თქვენ შეგიძლიათ ჩართოთ პირობა სიის გააზრებაში, რომელიც მოთავსებულია iterable-ის შემდეგ. """
group = [x for x in names if x[0] != "A"]


""" პროგრამირებისას, შეცდომები ხშირია, მიუხედავად გამოცდილების დონისა. ისინი შეიძლება მერყეობდეს მცირე შეცდომებიდან რთულ ლოგიკურ შეცდომებამდე. 
 პითონში არსებული შეცდომები შეიძლება დაიყოს ორ ტიპად:  ბაგები და გამონაკლისები"""

"""ბაგები არის ხარვეზები ან შეცდომები პროგრამის კოდში, რაც იწვევს არასწორ ან გაუთვალისწინებელ ქცევას. ეს სულაც არ აჩერებს პროგრამის მუშაობას დასრულებამდე, 
 მაგრამ შეიძლება გამოიწვიოს არასწორი შედეგები ან ქცევა. ბაგები, რომლებიც ხშირად გამოწვეულია ლოგიკური შეცდომებით, 
 შეიძლება გამოიწვიოს მოულოდნელი ან არასწორი შედეგები. """

""" გამონაკლისი არის შეცდომების კიდევ ერთი კატეგორია პროგრამირებაში. 
 ეს არის სპეციფიკური შეცდომები, რომლებიც წარმოიქმნება პროგრამის შესრულების დროს და წყვეტს მის ნორმალურ ნაკადს პირველად შეხვედრისას. 
 პითონში რამდენიმე სახის გამონაკლისი არსებობს. NameError გამონაკლისი ჩნდება უცნობი ცვლადის გამოყენებისას. 
 SyntaxError გამონაკლისი ჩნდება კოდში სინტაქსური შეცდომის აღმოჩენისას. 
 ეს შეიძლება იყოს სხვადასხვა მიზეზის გამო, როგორიცაა პუნქტუაციის გამოტოვება (როგორიცაა მძიმეები, ფრჩხილები ან ორწერტილები). 
 IndexError ჩნდება, როდესაც თქვენ ცდილობთ შეხვიდეთ გამეორებადი, დალაგებული კოლექციის ელემენტებზე, როგორიცაა სიები და ტუპლები, ინდექსის გამოყენებით, 
 რომელიც მის მოქმედ დიაპაზონს მიღმაა. TypeError გამონაკლისი ჩნდება, როდესაც ფუნქცია გამოიძახება შეუსაბამო ტიპის მნიშვნელობაზე. 
 მაგალითად, len() ფუნქციის გამოძახება შესაძლებელია მხოლოდ iterable-ებზე (როგორიცაა სტრინები, სიები და ა.შ.). 
 ValueError გამონაკლისი ჩნდება, როდესაც ფუნქცია იღებს სწორი ტიპის მნიშვნელობას, მაგრამ თავად მნიშვნელობა შეუსაბამო ან მიუღებელია.
 მაგალითად, int() ფუნქციის გამოძახება შესაძლებელია სტრინგებზე, მაგრამ მხოლოდ მაშინ, როდესაც სტრიგების ყველა სიმბოლო არის რიცხვითი მნიშვნელობები. 
 """
""" გამონაკლისები ხშირად წარმოიქმნება სხვადასხვა მიზეზის გამო, მათ შორის არასწორი შეყვანის, საზღვრებს გარეთ ინდექსების,
 შეუთავსებელი ტიპის ოპერაციების და ლოგიკური შეცდომების კოდში. კარგი ამბავი ის არის, რომ გამონაკლისები ხშირად პროგნოზირებადია,
 რაც დეველოპერებს საშუალებას აძლევს განჭვრიტონ და ეფექტურად გაუმკლავდნენ მათ. """

""" გამონაკლისები ხშირად შეიძლება პროგნოზირებადი იყოს. მათ დასამუშავებლად და პროგრამის წარუმატებლობის თავიდან ასაცილებლად, 
 შეგიძლიათ გამოიყენოთ try/except განცხადება. try ბლოკი შეიცავს კოდს, რამაც შეიძლება გამონაკლისი გამოიწვიოს. 
 თუ გამონაკლისი მოხდა, try ბლოკის შესრულება ჩერდება და except ბლოკი შესრულდება, რაც პროგრამას საშუალებას აძლევს გააგრძელოს მუშაობა. """
 
""" როდესაც თქვენ მიუთითებთ მხოლოდ ერთი ტიპის გამონაკლისის დასამუშავებლად, სხვა ტიპის გამონაკლისები არ იქნება დაფარული. 
 თუ ეს სხვა გამონაკლისები მოხდება, პროგრამის შესრულება ვერ მოხერხდება. """

""" თქვენ შეგიძლიათ გქონდეთ მრავალი  exept ბლოკი თითოეული შესაძლო გამონაკლისისთვის. """

""" თქვენ შეგიძლიათ არ მიუთითოთ გამონაკლისის ტიპი, რომელიც საშუალებას გაძლევთ გაუმკლავდეთ ნებისმიერ გამონაკლისს, რომელიც შეიძლება მოხდეს. 
 მიუხედავად იმისა, რომ ეს მიდგომა უფრო ადვილია, უარყოფითი მხარე ის არის, რომ შეცდომის შეტყობინებები შეიძლება არ იყოს ისეთივე ნათელი და გამოსადეგი. """

""" თქვენ შეგიძლიათ გამოიყენოთ finally ბრძანება იმისათვის, რომ შეასრულოთ ოპერაცია ბლოკის try/except ბლოკის შემდეგ, არ აქვს მნიშვნელობა მოხდა გამონაკლისი თუ არა. """

names = ["rati", "luka", "nika", "guka"]
try:
    print(names[10])
except:
    print("enter valid index")
finally:
    print("hello world")


""" სხვა განცხადება შეიძლება გამოყენებულ იქნას try/except ბლოკთან ერთად და შესრულდება მხოლოდ მაშინ, როდესაც შეცდომა არ მოხდება try ბლოკში. """

names = ["rati", "luka", "nika", "guka"]
try:
    print(names[0])
except:
    print("enter valid index")
else:
    print("hello world")

""" თქვენ შეგიძლიათ გაააქტიუროთ საკუთარი გამონაკლისები კონკრეტულ პირობებზე დაყრდნობით, raise განაცხადის გამოყენებით. 
 ეს დაუყოვნებლივ შეაჩერებს პროგრამის შესრულებას და მიუთითებს, რომ მოხდა შეცდომა. """

"""price = 995
if price > 500:
  raise ValueError"""

""" ჩვენ შეგვიძლია ცვლადს მივანიჭოთ ფუნქცია. """
def welcome(name):
  return "Welcome, " + name
greet = welcome

""" ცვლადისთვის ფუნქციის მინიჭების შემდეგ, შეგიძლიათ გამოიყენოთ ცვლადი ფუნქციის გამოსაძახებლად. """

"""ფუნქციებს შეუძლიათ სხვა ფუნქციები არგუმენტად მიიღონ.
 მაგ: """
 
def order(dish):
    return "Your order: " + dish

def process_order(dish, func):
    print(func(dish))

process_order("Spaghetti", order)

""" პითონში, ფუნქციებს, რომლებიც მოქმედებენ სხვა ფუნქციებთან - ანუ იღებენ სხვა ფუნქციას არგუმენტად ან აბრუნებენ ფუნქციას - ეწოდება უმაღლესი რიგის ფუნქციები. 
ისინი განსაკუთრებით სასარგებლოა სხვადასხვა ფუნქციების დასამუშავებლად და კონკრეტული შედეგების დასაბრუნებლად. """

""" ფუნქციური პროგრამირების მნიშვნელოვანი კონცეფციაა სუფთა ფუნქციები.
 ფუნქციას ეწოდება სუფთა, თუ ის იძლევა ერთსა და იმავე შედეგს ყოველ ჯერზე, როცა მას ერთსა და იმავე შეყვანას აძლევთ და ის არ ახდენს გავლენას ფუნქციის მიღმა რაიმეზე. 
 ეს ხდის მათ სანდოს და ადვილად გასაგებს. """

""" ფუნქცია არ არის სუფთა, თუ ის დამოკიდებულია რომელიმე გარე მდგომარეობაზე, რომელსაც ის ცვლის ან გავლენას ახდენს მის მუშაობაზე. 
 ეს მოიცავს ცვლადების ან შეყვანილი არგუმენტების შეცვლას. 
 ასეთი დამოკიდებულებები ფუნქციის ქცევას არაპროგნოზირებადს ხდის და დამოკიდებულია კონტექსტზე, რომელშიც ის მუშაობს. """

""" ფუნქციურ პროგრამირებას აქვს უპირატესობები თქვენი კოდის უფრო ეფექტურისა და ორგანიზებულის გახდის თვალსაზრისით. 
 ლამბდა გამონათქვამები არის ფუნქციები სახელის გარეშე, რომლებიც სწრაფად იქმნება და გამოიყენება. 
 ისინი იწერება მხოლოდ ერთ სტრიქონში ლამბდა საკვანძო სიტყვის გამოყენებით და ხშირად გამოიყენება მცირე, მარტივი ამოცანებისთვის. 
 ლამბდა გამონათქვამებს ანონიმურ ფუნქციებს უწოდებენ. ეს ნიშნავს, რომ მათ არ სჭირდებათ სახელი. 
 ლამბდა გამონათქვამები ასრულებენ ერთ ოპერაციას და აბრუნებენ შედეგს.
 ჩვენ შეგვიშძლია ლამბდა ფუნქცია შეინახოთ ცვლადში და შემდეგ როგორც ნორმალური ფუნქცია ისე გამოიძახოთ 
 ლამბდა გამონათქვამებს შეუძლიათ მიიღონ მრავალი არგუმენტი, რომლებიც გამოყოფილია მძიმეებით. 
 ლამბდაები ასრულებენ ერთ, ლაკონურ ოპერაციას. ისინი უფრო შეზღუდულია ვიდრე ჩვეულებრივი ფუნქციები, 
 რომლებსაც შეიძლება ჰქონდეთ მრავალი ხაზი და მოქმედება, და იდეალურია პირდაპირი, მარტივი ოპერაციებისთვის. 
 ჩვენ შეგვიძლია ლამბდას ძალიან თავისუფლად და ჰაერზე დავამატოთ არგუმენტები, მხოლოდ ამ არგუმენტისა(ებისა) და ლამბდა გამონათქვამის ფრჩხილებში ჩასმით."""
 
x = lambda price, count :  price * count
print(x(2,10))

x1 = (lambda price, count :  price * count) (2, 10)
print(x1)

""" map() ფუნქცია იყენებს მითითებულ ფუნქციას iterable-ის ყველა ელემენტზე, როგორიცაა სიები ან ტუპლები. 
 ის აწარმოებს შედეგს, რომელიც შეიძლება გარდაიქმნას სიაში list() ფუნქციის გამოყენებით მარტივი ნახვის ან შემდგომი გამოყენებისთვის.
 map() ფუნქცია მოითხოვს, რომ პირველი არგუმენტი იყოს ფუნქცია და მეორე არგუმენტი იყოს iterable. 
 ლამბდა გამონათქვამის კიდევ ერთი ღირებული ასპექტია მათი უნარი უშუალოდ მიეწოდოს რუკის ფუნქციას. 
 ეს გამორიცხავს რეგულარული ფუნქციის მკაფიოდ განსაზღვრის აუცილებლობას."""

""" filter() ფუნქცია, ისევე როგორც map() ფუნქცია, არგუმენტად იღებს ფუნქციას და iterable-ს. 
 filter()-ის მთავარი მიზანია გამოიყენოს მოწოდებულ ფუნქციაში მითითებული პირობა iterable-ის თითოეულ ელემენტზე და დააბრუნოს მხოლოდ ის, 
 რისთვისაც ფუნქცია ფასდება True-ზე. filter() ფუნქცია განსაკუთრებით სასარგებლოა მონაცემების ქვეჯგუფების ამოსაღებად, რომლებიც აკმაყოფილებენ გარკვეულ კრიტერიუმებს.~
 map() და filter() ფუნქციებს შეუძლია ნებისმიერ iterable-თან მუშაობა. """
 
exam_scores = [85, 62, 95]
def is_passing(score):
  return score >= 70

status = list(map(is_passing, exam_scores))
status1 = list(filter(is_passing, exam_scores))

scores = [1,5,2,3,8,6,4]
map(lambda x: x+5, scores)
filter(lambda x: x+5, scores)

""" თუ თქვენი ფუნქციის არგუმენტების რაოდენობა უცნობია და არაპროგნოზირებადია, ყოველთვის შეგიძლიათ გამოიყენოთ iterable არგუმენტად.
 *args გაძლევთ საშუალებას მოგაწოდოთ ნებისმიერი რაოდენობის არგუმენტი სიის შექმნის საჭიროების გარეშე ფუნქციის ყოველ ჯერზე გამოძახებამდე. 
 თქვენ უნდა გამოიყენოთ ოპერატორი * args-მდე. ეს ოპერატორი აცნობებს Python-ს, რომ არგუმენტი არის iterable და უნდა იყოს გახსნილი, 
 რომ მიიღოს მისი მნიშვნელობები, როგორც ინდივიდუალური არგუმენტები. გაითვალისწინეთ, რომ args მხოლოდ სახელია. 
 თქვენ არ გჭირდებათ სახელის გამოყენება args. თქვენ შეგიძლიათ აირჩიოთ თქვენთვის სასურველი ნებისმიერი სახელი. 
 ფუნქციის როგორც რეგულარული არგუმენტებით, ასევე *args-ით განსაზღვრისას, ფუნქციის განსაზღვრაში რეგულარული არგუმენტები *args-მდე უნდა იყოს."""

def display(*words):
  for item in words:
    print(item)
display("paper", "pen", "pencil")

""" პითონი ასევე გაძლევთ საშუალებას გადასცეთ საკვანძო სიტყვების არგუმენტები **kwargs-ის გამოყენებით. 
 ამ შემთხვევაში **kwargs იღებს არგუმენტებს ლექსიკონის სახით, რომელიც შედგება სახელი:მნიშვნელობის წყვილებისგან. 
 ** ოპერატორი Python-ში გამოიყენება ლექსიკონების არგუმენტებად გასახსნელად. 
 ის საშუალებას აძლევს ფუნქციას მიიღოს საკვანძო სიტყვების არგუმენტების თვითნებური რაოდენობა, გარდაქმნას ეს არგუმენტები გასაღები:მნიშვნელობის წყვილების ლექსიკონად.
*args: tuple
**kwargs: dictionary
 ფუნქციის განსაზღვრაში მნიშვნელოვანია არგუმენტების თანმიმდევრობა. პირველ რიგში, ჩამოთვლილია რეგულარული არგუმენტები, რასაც მოჰყვება *args და ბოლოს **kwargs.
 პითონში ფუნქციების ჩადგმა შესაძლებელია. ეს ნიშნავს, რომ თქვენ შეგიძლიათ განსაზღვროთ ფუნქცია სხვა ფუნქციის სხეულში. """

""" წარმოიდგინეთ, რომ გაქვთ ფუნქცია, რომელიც ქმნის შეტყობინებას. თქვენი მიზანია შექმნათ სხვა ფუნქცია, 
 რომელიც მიიღებს ამ ორიგინალურ ფუნქციას არგუმენტად და გარდაქმნის თავდაპირველ შეტყობინებას დიდ ასოებში, 
 ორიგინალური ფუნქციის კოდის შეცვლის გარეშე. ეს ფუნქციები ცნობილია როგორც დეკორატორები. 
 თქვენ შეგიძლიათ გამოიყენოთ დეკორატორი ფუნქციაზე @ ნიშნის გამოყენებით. ის აუმჯობესებს კოდის წაკითხვას 
 და უზრუნველყოფს სუფთა გამიჯვნას ფუნქციასა და მის დეკორაციას შორის.
 დეკორატორთან ფუნქციის გამოძახებისას ის ავტომატურად მოიცავს დეკორატორში განსაზღვრულ ქცევას. 
 დეკორატორები მძლავრი ფუნქციაა, რომელიც გთავაზობთ ლაკონურ, წასაკითხ და ეფექტურ გზას არსებული ფუნქციების ფუნქციონირების გასაუმჯობესებლად.
 თქვენ შეგიძლიათ გამოიყენოთ ერთი და იგივე დეკორატორი რამდენიმე სხვადასხვა ფუნქციისთვის:"""

def greet(name):
   print("hey", name)

   def account():
      return "your account has created"
   message = account()
   return message

print(greet("rati"))


def order():
  def prepare():
    return "Your meal is being prepared!"
  status = prepare()
  return status

print(order())


""" რეალურ სამყაროში ნივთების უმეტესობას აქვს „გეგმა“ და მისი მრავალი მაგალითი. „გეგმით“ ჩვენ ვგულისხმობთ თვისებებისა და ქცევების აბსტრაქტულ ერთობლიობას. 
აიღეთ, მაგალითად, "მანქანა". ეს არის გეგმა, ან ზოგადი იდეა, რომელიც მოიცავს ისეთ თვისებებს, როგორიცაა ოთხი ბორბალი, ფერი, ძრავის სიმძლავრე და ა.შ. 
მანქანები, რომლებსაც გზაზე ხედავთ, არის ამ ზოგადი გეგმის კონკრეტული შემთხვევები, თითოეულს აქვს თავისი უნიკალური მახასიათებლები, როგორიცაა ფერი, მარკა და მოდელი. 

პროგრამირებაში არსებობს პარადიგმა, რომელიც მიჰყვება იმავე პრინციპებს, როგორც გეგმებსა და მაგალითებს. მას ეწოდება Object-Oriented Programing (OOP)
 OOP-ში, გეგმებს მოიხსენიებენ, როგორც კლასებს, ხოლო მაგალითებს უწოდებენ ობიექტებს. 
 პითონში შეგიძლიათ კლასის განსაზღვრა კლასის საკვანძო სიტყვის გამოყენებით, რასაც მოჰყვება კლასის სახელი და ორწერტილი. 
 რეალურ სამყაროში ყველაფერს აქვს განმასხვავებელი მახასიათებლები: ძაღლს აქვს თავისი ჯიში, ფერი და სახელი; 
 მანქანას აქვს თავისი ბრენდი, მოდელი და ფერი. პროგრამირებაში კლასები და ობიექტები ამ კონცეფციას ასახავს ატრიბუტებით. 
 ატრიბუტები არის თვისებები, რომლებიც განსაზღვრავენ ობიექტის ინდივიდუალურობას კლასში. კლასში ატრიბუტების დასამატებლად, 
 თქვენ უნდა განსაზღვროთ __init__ მეთოდი. ამ მეთოდის პირველი პარამეტრი ყოველთვის არის self, რომელიც წარმოადგენს კლასის მაგალითს. 
 საკუთარი თავის შემდეგ, თქვენ მიუთითებთ ატრიბუტებს, რომელთა ჩართვა გსურთ. შემდეგ, ფუნქციის შიგნით, თქვენ ანიჭებთ მნიშვნელობებს 
 ინიციალიზებული ობიექტის ატრიბუტებს, აყენებთ მათ საწყის მდგომარეობას. ობიექტის შექმნის შემდეგ შეგიძლიათ მის ატრიბუტებზე წვდომა წერტილის გამოყენებით.
 აღნიშვნა ცვლადით, რომელიც შეიცავს ობიექტს. ატრიბუტების გარდა, შეგიძლიათ დაამატოთ კლასში მორგებული ქცევები მასში ფუნქციების განსაზღვრით. 
 ეს ფუნქციები, რომლებიც ცნობილია როგორც მეთოდები, უნდა შეიცავდეს "self" პარამეტრს. ამ მეთოდებს შეგიძლიათ გამოუძახოთ წერტილის გამოყენებით, 
 ისევე, როგორც თქვენ წვდებით ატრიბუტებს. ფუნქციებსა და მეთოდებს შორის მთავარი განსხვავება ისაა, რომ ფუნქციები დამოუკიდებელია და მათი დამოუკიდებლად
 გამოძახებაა შესაძლებელი, ხოლო მეთოდები ასოცირდება კლასთან და შეიძლება გამოიძახონ მხოლოდ მის მაგალითთან. 
 ეს ნიშნავს, რომ მეთოდის გამოძახება შეუძლებელია კლასის ინსტანციის გარეშე, სადაც ეს მეთოდი არის განსაზღვრული. """

class vehicle:

  def __init__(self, brand, color):
    self.brand = brand
    self.color = color

  def honk(self):
     print("beep beep")

my_vehicle = vehicle("Audi", "yellow")
print(my_vehicle)
print(my_vehicle.brand)
print(my_vehicle.color)
my_vehicle.honk()

""" Python-ში ბევრი ჩაშენებული მეთოდია, რომელთაგან ზოგიერთს უკვე იცნობთ. 
 მაგალითად, low(), upper() და capitalize() მეთოდები ჩვეულებრივ გამოიყენება სტრინგის ობიექტებზე. """

"madrid".upper()
"madrid".capitalize()
"MADrid".lower()

""" პითონში ყველაფერი, ფუნქციების ჩათვლით, არის ობიექტი. მაგალითად, მთელი რიცხვები არის int კლასის ეგზემპლარები, 
 ხოლო ფუნქციები არის ფუნქციის კლასის შემთხვევები,. ეს ობიექტზე ორიენტირებული ბუნება საფუძვლად უდევს პითონის მოქნილობასა და ძალას. """



""" OOP-ის სიძლიერე მდგომარეობს პროგრამის ორგანიზებაში, რათა მისმა სხვადასხვა კომპონენტმა, 
 რომელიც განიხილება კლასებად და ობიექტებად, შეუფერხებლად ურთიერთქმედება. """

""" 
მემკვიდრეობა არის საკვანძო კონცეფცია სიტუაციებისთვის, როდესაც თქვენ გაქვთ არსებული კლასი განსაზღვრული ატრიბუტებითა და ქცევებით, და გჭირდებათ ახალი კლასი, 
 რომელიც არა მხოლოდ იზიარებს ამ მახასიათებლებს, არამედ აქვს საკუთარი უნიკალური. მემკვიდრეობა საშუალებას აძლევს ახალ კლასს „მემკვიდროს“ თვისებები არსებული
 კლასიდან და საჭიროების შემთხვევაში დაამატოს ან შეცვალოს კონკრეტული მახასიათებლები. ბავშვის კლასი მემკვიდრეობით იღებს მშობელი კლასის ყველა ატრიბუტსა და მეთოდს.
 რა მოხდება, თუ გვსურს არა მხოლოდ მემკვიდრეობით მივიღოთ ატრიბუტები, არამედ დავამატოთ კონკრეტული ატრიბუტები ბავშვთა კლასს? 
 ამ შემთხვევაში, ჩვენ განვსაზღვრავთ __init__ მეთოდს ბავშვის კლასში. გამოიყენეთ super().__init__() მშობელი კლასიდან ატრიბუტების მემკვიდრეობისთვის 
 და შემდეგ განსაზღვრეთ ნებისმიერი დამატებითი ატრიბუტი, როგორც ყოველთვის. __init__ ის გამოყენების შემდეგ მემკვიდრე კლასში შეგვიძლია შევქმნათ ახალი მეთოდი, 
 რომელსაც დავარქმევთ იმავე სახელს რაც მშობელ კლასში, თუმცა მას ამის მიუხედავად ექნება სხვა ფუნქცია. super() ფუნქციის გამოყენებით ჩვენ შეგვიძლია დავუბრუნოთ მემკვიდრე 
 კლასს მშობლის კლასში შექმნილი მეთოდი. მეთოდის გადაფარვა არის OOP-ის კიდევ ერთი ძირითადი კონცეფციის - პოლიმორფიზმის დემონსტრირება. 
 პოლიმორფიზმი საშუალებას აძლევს ობიექტებს გამოიყენონ მეთოდები საკუთარი გზით, თუნდაც მათ იგივე სახელი ჰქონდეთ.
 აბსტრაქცია, მემკვიდრეობა და პოლიმორფიზმი არის OOP-ის ოთხი ფუნდამენტური პრინციპიდან სამი"""


class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)

x = Student("Mike", "Olsen")
x.printname()




class Car:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Drive!")

class Boat:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Sail!")

class Plane:
  def __init__(self, brand, model):
    self.brand = brand
    self.model = model

  def move(self):
    print("Fly!")

car1 = Car("Ford", "Mustang")       #Create a Car class
boat1 = Boat("Ibiza", "Touring 20") #Create a Boat class
plane1 = Plane("Boeing", "747")     #Create a Plane class

for x in (car1, boat1, plane1):
  x.move()



""" მონაცემთა დამალვა(data hiding) არის საკვანძო იდეა, რათა კოდი უფრო უსაფრთხო და სუფთა იყოს ობიექტებით (როგორიცაა თამაშებში ან აპებში). 
 ეს ნიშნავს ობიექტის ზოგიერთი ნაწილის კონფიდენციალურობას ისე, რომ თქვენი კოდის მხოლოდ გარკვეულმა ნაწილმა შეძლოს მათი შეცვლა. 
 ეს დაგეხმარებათ შეცდომების თავიდან აცილებაში და თქვენი კოდის მარტივად მართვაში. როგრამირებისას, ზოგჯერ გადამწყვეტია კლასის გარკვეული 
 ატრიბუტებისა და მეთოდების „დაცვა“ კლასის გარეთ წვდომისგან. ამას ეწოდება მონაცემთა დამალვა და უზრუნველყოფს მონაცემთა მთლიანობასა და უსაფრთხოებას, 
 თავიდან აიცილებს გაუთვალისწინებელ ან მავნე მოდიფიკაციას. 
 პითონში მონაცემების დამალვას ორი დონე აქვს. პირველი გულისხმობს ატრიბუტის პრეფიქსს ერთი ქვედა ხაზით _, 
 რაც მიუთითებს, რომ ის განკუთვნილია შიდა გამოყენებისთვის და უნდა განიხილებოდეს როგორც "დაცული". ერთი ხაზგასმული ატრიბუტები ხელმისაწვდომია, 
 მაგრამ დაცულად ითვლება კონვენციით, რაც მიუთითებს იმაზე, რომ ისინი შიდა გამოყენებისთვისაა და ფრთხილად უნდა იყოს წვდომა კლასის გარეთ.
 კლასის გარეთ დაცულ ატრიბუტზე წვდომისთვის გამოიყენეთ ერთი ხაზგასმული პრეფიქსი, რადგან ეს ატრიბუტის სახელის ნაწილია. 
 მონაცემთა დამალვის შემდეგი დონე გულისხმობს ატრიბუტის პრივატიზაციას. 
 ეს მიიღწევა ატრიბუტის სახელის პრეფიქსით ორი ქვედა ხაზით (მაგ., __ატრიბუტი). 
 ამ შემთხვევაში, დაცული ატრიბუტებისაგან განსხვავებით, ეს არ არის მხოლოდ კონვენცია - ის ზღუდავს მის წვდომას კლასის გარეთ სახელების მანიპულირების, 
 მონაცემთა დაცვისა და ინკაფსულაციის გაძლიერების გზით. ეს მეთოდი გამოიყენება სენსიტიური ან შიდა მონაცემებისთვის, რაც ძლიერ აფერხებს გარე წვდომას. 
 კერძო(private) ატრიბუტზე წვდომა კლასის გარედან ორმაგი ხაზებით იწვევს შეცდომას, მაგრამ ის ხელმისაწვდომია კლასის მეთოდებში. 
 ეს აჩვენებს ინკაფსულაციას, იცავს მგრძნობიარე მონაცემებს გარე წვდომისგან და უზრუნველყოფს მის მიღწევას მხოლოდ კონკრეტული მეთოდებით, 
 ობიექტზე ორიენტირებული პროგრამირების პრინციპებთან შესაბამისობაში. 
 პირად ატრიბუტზე წვდომა უშუალოდ მისი კლასის გარედან საერთოდ არ არის წახალისებული Python-ში. 
 თუმცა, Python იყენებს სახელების მანიპულირებას კერძო ატრიბუტებისთვის, რაც ნიშნავს, 
 რომ საჭიროების შემთხვევაში შეგიძლიათ მათზე წვდომა კონკრეტული დასახელების კონვენციის გამოყენებით კლასის გარედან."""


class mars:
    def __init__(self, brand, model, power):
        self.__brand = brand           # Private attribute
        self._model = model            # Protected attribute
        self.mileage = power           # Public attribute

mycar = mars("BMW", "AMG", 10.0)

# Accessing attributes using correct names
print(mycar._mars__brand)  # Accessing private attribute using name mangling
print(mycar._model)        # Accessing protected attribute directly (discouraged)
print(mycar.mileage)       # Accessing public attribute directly



""" კლასის მეთოდები იწოდება თავად კლასზე და არა ცალკეულ ინსტანციებზე. ეს საშუალებას აძლევს მათ გამოიყენონ კლასის ინსტანციის შექმნის გარეშე. 
 ისინი განსაკუთრებით სასარგებლოა მთლიანი კლასისთვის შესაბამისი მოქმედებებისთვის, ვიდრე ერთი ობიექტით შეზღუდული მოქმედებებისთვის. 
 კლასის მეთოდები იქმნება @classmethod დეკორატორის გამოყენებით და იღებენ cls არგუმენტს, რომელიც ეხება თავად კლასს. 
 კლასის მეთოდის გამოსაძახებლად, თქვენ არ გჭირდებათ კლასის ეგზემპლარის შექმნა. 
 ამის ნაცვლად, უბრალოდ გამოიყენეთ კლასის სახელი, რასაც მოჰყვება წერტილი და კლასის მეთოდის სახელი. 
 ინსტანციები იზიარებენ ყველაფერს, რაც აქვს კლასს, კლასის მეთოდების ჩათვლით. ეს ნიშნავს, რომ თქვენ იძახით კლასის მეთოდს ინსტანციებზეც."""

class Car:
    car_count = 0

    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        Car.car_count += 1

    @classmethod
    def get_car_count(cls):
        return cls.car_count

    @classmethod
    def create_from_string(cls, car_string):
        brand, model = car_string.split('-')
        return cls(brand, model)

# Using the class method to create instances and retrieve class-level data
car1 = Car("Toyota", "Camry")
car2 = Car.create_from_string("Honda-Civic")

print("Total number of cars created:", Car.get_car_count())  # Output: 2


""" სტატიკური მეთოდები კლასის მეთოდების მსგავსია, გარდა იმისა, რომ ისინი არ იღებენ დამატებით არგუმენტებს; 
 ისინი იდენტურია ნორმალური ფუნქციების, რომლებიც მიეკუთვნება კლასს.
 ისინი მონიშნულია @staticmethod დეკორატორით. 
 როდის უნდა გამოიყენოთ სტატიკური მეთოდები კლასის მეთოდების ნაცვლად? 
 სტატიკური მეთოდები არ იღებენ cls პარამეტრს, რაც იმას ნიშნავს, რომ მათ არ შეუძლიათ წვდომა ან შეცვალონ კლასის მდგომარეობა. 
 ისინი სასარგებლოა, როდესაც გჭირდებათ ფუნქციონირება, რომელიც არ არის დამოკიდებული კლასის ქცევაზე ან მაგალითზე და არ ახდენს გავლენას მასზე. 
 არსებითად, სტატიკური მეთოდები შეეფერება ამოცანებს, რომლებიც დამოუკიდებელია და არ საჭიროებს კლასის ან ინსტანციის ცოდნას."""

class MathOperations:
    @staticmethod
    def add_numbers(x, y):
        return x + y

# Using the static method without creating an instance
result = MathOperations.add_numbers(5, 3)
print("Result of addition:", result)  # Output: 8


