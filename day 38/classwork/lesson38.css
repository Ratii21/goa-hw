/*  გარე CSS კოდი იწერება HTML დოკუმენტის გარეთ, ცალკე ფაილში. 
 თქვენ არ გჭირდებათ <style> თეგები გარე CSS ფაილში. თქვენ შეგიძლიათ პირდაპირ დაამატოთ სტილის წესები. 
 მაგალითად ავიღოთ ფერის შეცვლა: */
#h1 {
    color: rgb(72, 0, 255)
  }

/* ფერადი მოდელი არის რეალური ფერების წარმოდგენისა და ხელახალი შექმნის გზა კოდების გამოყენებით. 
 RGB არის ერთ-ერთი ყველაზე ხშირად გამოყენებული ფერის მოდელი. RGB იშიფრება როგორც Red, Green, Blue. 
 RGB მოდელი ქმნის ფერებს წითელი, მწვანე და ლურჯის სხვადასხვა რაოდენობის (ინტენსივობის) შერწყმით; თითოეული 0-დან 255-მდე მერყეობს.
 rgb(0, 0, 0) წარმოადგენს ყველაზე მუქს (შავ ფერს)  ხოლო rgb(255, 255, 255) შესაბამისად ყველაზე ღიას (თეთრ ფერს) */
/* 
rgb(255, 0, 0): red
rgb(0, 255, 0): green
rgb(0, 0, 255): blue
rgb(255, 255, 255): white
rgb(0, 0, 0): black
rgb(255, 255, 0): yellow
*/

#p{ 
    color: brown;
 }

    
/* ფერები RGB მოდელში ასევე შეიძლება წარმოდგენილი იყოს HEX კოდებით.
 HEX კოდები უფრო მოკლეა. HEX კოდები იწყება ჰეშის სიმბოლოთი #, 
 რასაც მოჰყვება 3 წყვილი სიმბოლოებისა, თითოეული წარმოადგენს წითელი, მწვანე და ლურჯის ინტენსივობას შესაბამისად. 
 HEX კოდის თითოეულ სიმბოლოს შეიძლება ჰქონდეს 16 შესაძლო მნიშვნელობიდან ერთ-ერთი, რომელიც მოიცავს 0-დან 9-მდე და ვრცელდება A-დან F ასოებამდე.
 თითოეული წყვილი მერყეობს 00-დან (უმცირესი ინტენსიური) FF-მდე (ყველაზე ინტენსიური). HEX სისტემაში რიცხვების წარმოდგენა უფრო ეფექტურია.
 თითო ფერზე საჭიროა მხოლოდ 2 ციფრი.*/
/* 
rgb(255, 0, 0): #FF0000
rgb(0, 255, 0): #00FF00
rgb(0, 0, 255): #0000FF
#000000: black
#FFFFFF: white
#FF0000: red
*/
/* ფერის მოდელები და კოდები საჭიროა, რადგან ძალიან ბევრი ფერია და ყველას სახელი ვერ ერქმევა. 
 ეკრანის მოწყობილობები, როგორიცაა თქვენი ტელეფონის ეკრანი, დამზადებულია სურათის პატარა ელემენტებისაგან, რომლებიც ცნობილია როგორც პიქსელები.
 თითოეულ პიქსელს შეუძლია ასხივოს წითელი, მწვანე და ლურჯი შუქის კომბინაცია RGB მოდელში, ნებისმიერი ფერის შესაქმნელად.*/


/* იმისათვის, რომ გვერდები ლამაზად და დაბალანსებულად გამოიყურებოდეს, ელემენტების ზომა სრულად უნდა ვაკონტროლოთ. 
 ტელეფონის ეკრანის მსგავსი დისპლეი დამზადებულია სურათის ელემენტებით ან პიქსელებით. პიქსელები გამოიყენება როგორც საზომი ერთეული ელემენტების ზომების გასაკონტროლებლად.
 font-size თვისება აკონტროლებს ტექსტის ზომას. */
#p1{
    font-size:32px;
    }
    
button{
    font-size:40px;
    }
    
/* უმეტეს ვებ ბრაუზერებში, ტექსტის ჩვეულებრივი ზომა პარაგრაფებში, ღილაკებში, სიებსა და ცხრილებში არის 16px. 
 ტექსტის ზომისთვის შეგიძლიათ გამოიყენოთ მნიშვნელობები, როგორიცაა small, medium, და large. მათ უკვე აქვთ პიქსელების გარკვეული რაოდენობა. 
 უფრო ზუსტად:
small: 13px
medium: 16px
large: 18px
*/

/* თანამედროვე ვებსაიტები შექმნილია იმისთვის, რომ მშვენივრად გამოიყურებოდეს სხვადასხვა ზომის და გარჩევადობის ეკრანებზე. 
 ეს მიდგომა ცნობილია როგორც responsive web design.
 პიქსელების, როგორც საზომი ერთეულის გამოყენება არ არის საუკეთესო პრაქტიკა, როდესაც საქმე ეხება responsive web design.
 სხვადასხვა ზომის და გარჩევადობის ეკრანებს აქვთ სხვადასხვა რაოდენობის პიქსელი და პიქსელები ფიქსირებული ზომის ერთეულებია. 
 იმისათვის, რომ თქვენი გვერდის დიზაინი მშვენივრად გამოიყურებოდეს ნებისმიერ ეკრანზე, პროცენტები (%) გამოიყენება ფარდობითი ზომების დასაყენებლად. 
 ეს უზრუნველყოფს თანმიმდევრულ დიზაინს სხვადასხვა ზომის ეკრანზე.
 width-ის შემთხვევაში ჩვენ მივუთითებთ თუ ეკრანის სიგანის რამდენი პროცენტი უნდა დაიკავოს ელემენტმა.*/

img{
    width: 50%;
}

/* ჩვეულებრივ, გვერდის სხეულის სიგანე ემთხვევა მოწყობილობის ეკრანის სიგანეს. ეს ძალიან სასარგებლოა responsive web-ის შესაქმნელად.
 თქვენ ასევე შეგიძლიათ გამოიყენოთ პროცენტები შრიფტის ზომის დასაყენებლად. შრიფტის ზომები გამოითვლება პირველადი შრიფტის ზომის გამოყენებით.
 თუ პირველადი ზომა დაყენებულია 20 პიქსელზე,  მეორეული(სტილირებული) 50% შრიფტის ზომით აჩვენებს 10 პიქსელ ტექსტს.
 ბრაუზერების უმეტესობაში გვერდის ძირითადი(პირველადი) შრიფტის ნაგულისხმევი ზომა არის 16 პიქსელი.*/


/* Text alignment - ტექსტის მდებარეობა */
#center{
    text-align: center;
}

#left{
    text-align: left;
}

#right{
    text-align: right;
}

/* გამოიყენეთ text-align: justify ტექსტის გასასწორებლად, როგორც მარცხენა, ასევე მარჯვენა კიდეებზე სიტყვებს შორის მანძილის კორექტირებით, 
 ისე რომ თითოეულ სტრიქონს ქონდეს თანაბარი სიგანე. */
#justify{
    text-align: justify;
}

/* text-decoration - ტექსტის დეკორაცია */
/* თქვენ შეგიძლიათ დაამატოთ  text-decoration მნიშვნელობის გადმოსაცემად ან ყურადღება მიიპყროთ ტექსტის კონკრეტულ ნაწილებზე, როგორიცაა ბმულები.*/
#offer b{
    text-decoration: overline;
}
/* ზოგიერთ CSS თვისებას შეუძლია მიიღოს მრავალი მნიშვნელობა. 
 თქვენ შეგიძლიათ აკონტროლოთ დეკორაციის ფერი, დეკორაციის ტიპის შემდეგ ფერის სახელის, rgb ან hex კოდის დამატებით. 
 */
#txt{
    text-decoration: underline red;
}
/* Text decoration-მა შეიძლება მიიღოს სხვადასხვა სტილი. 
 როგორიცაა: წერტილოვანი(dotted), ორმაგი(double), წყვეტილი(dashed) და ტალღოვანი(wavy). */

#dotted{
    text-decoration: underline dotted;
}
#double{
    text-decoration: underline double;
}
#dashed{
    text-decoration: underline dashed;
}
#wavy{
    text-decoration: underline wavy;
}

/* text-decoration თვისება არის მოკლე და მარტივი გზა სხვადასხვა ქვეთვისებებზე მითითებისთვის,
 როგორიცაა: text-decoration-line, text-decoration-color და text-decoration-style. 
 */


/* text-transform - ტექსტის ტრანსფორმაციის */
 /* ტექსტის ტრანსფორმაციის თვისება გაძლევთ საშუალებას აკონტროლოთ ტექსტის კაპიტალიზაცია.
 მას შეუძლია მიიღოს 3 მნიშვნელობა:  capitalize, uppercase და lowercase. */
#capitalize {
    text-transform: capitalize;
}
#uppercase {
    text-transform: uppercase;
}
#lowercase {
    text-transform: lowercase;
}

/*  text-shadow - ტექსტის ჩრდილი */
/* ტექსტის ჩრდილი ქმნის სიღრმის ეფექტს, ხაზს უსვამს ან უბრალოდ ალამაზებს.
 იგი იღებს ორ საჭირო მნიშვნელობას, 
 მოცემული თანმიმდევრობით: horizontal offset(ჰორიზონტალურად ჩრდილის დაშორება)(პირველი), vertical offset(ვერტიკალურად ჩრდილის დაშორება)(მეორე). 
 საზომ ერთეულებად აქაც ხშირად ვიყენებთ პიქსელებს. 
 horizontal offset არის რამდენად შორს იქნება ჩრდილი მარჯვნივ (დადებითი მნიშვნელობები) ან მარცხნივ (უარყოფითი მნიშვნელობები).
 vertical offset არის რამდენად შორს იქნება ჩრდილი ქვემოთ (დადებითი მნიშვნელობები) ან ზემოთ (უარყოფითი მნიშვნელობები).
 ტექსტის ჩრდილს შეუძლია მიიღოს ორი დამატებითი, არასავალდებულო მნიშვნელობა.
 blur radius(დაბინდვის რადიუსი):  დაბინდვის რაოდენობა, რომელიც გამოიყენება ჩრდილზე
 color(ფერი):  ჩრდილის ფერი
 დაბინდვის რადიუსი და ფერის მნიშვნელობები არჩევითია და შეიძლება გამოტოვოთ.
 
 text-shadow: horizontal offset, vertical offset, blur radius, color;
*/
 
 

#shadow {
    text-shadow: -2px 3px 2px blue;
}

/* შრიფტები გადამწყვეტ როლს თამაშობენ ვებ დიზაინში, გავლენას ახდენენ წაკითხვაზე, ესთეტიკასა და მომხმარებლის გამოცდილებაზე. 
 ისინი სიცოცხლეს აძლევენ სიტყვებს გვერდზე და აყალიბებენ შინაარსის ტონს. 
 font-family თვისება CSS-ში გაძლევთ საშუალებას მიუთითოთ თქვენი ტექსტის შრიფტი. ეს განსაზღვრავს, თუ როგორ გამოიყურება ტექსტი ვებ გვერდზე.
 ბევრი შრიფტი დაინსტალირებულია ჩვეულებრივად ყველა მოწყობილობაში. ეს ცნობილია, როგორც ვებ უსაფრთხო შრიფტები.
 ბევრ შრიფტს შეიძლება დასჭირდეს დაინსტალირება მომხმარებლის მოწყობილობაზე, ასე რომ თქვენ უნდა მიუთითოთ ვებ უსაფრთხო შრიფტი, 
 როგორც სარეზერვო საშუალება, იმ შემთხვევაში, თუ მომხმარებელს არ აქვს ისინი. 
ზოგიერთი ვებ სუსაფრთხო შრიფტი*/
#f1{
    font-family: Comic Sans MS;
}
#f2{
    font-family: Georgia;
 }
#f3{
    font-family: Tahoma;
}
#f4{
    font-family: Lucida Console;
}
#f5{
    font-family: Arial;
}
#f6{
    font-family: Courier New;
}
#f7{
    font-family: Times New Roman;
}
#f8{
    font-family: Trebuchet MS;
}
#f9{
    font-family: Verdana;
}
/* font-family თვისება განსაზღვრავს შრიფტების ჩამონათვალს, უმაღლესი პრიორიტეტიდან ყველაზე დაბალამდე. 
 შრიფტის შერჩევა ჩერდება სიის პირველ შრიფტზე, რომელიც არის მომხმარებლის სისტემაში. */

#f10 {
    font-family: Helvetica, Georgia, Arial;
    }
    
/* Generic font families არის შრიფტების ჯგუფები მსგავსი შრიფტით და ისინი გამოიყენება როგორც უნივერსალური ჩანაცვლება. 
 საუკეთესო პრაქტიკაა მათი განთავსება, როგორც ბოლო ვარიანტი შრიფტის სახით. 
 თუ სასურველი შრიფტები მიუწვდომელია, ბრაუზერები გამოიყენებენ ამ ტიპის შრიფტს. 
5 გავრცელებული generic font families:  */

#fa{
    font-family: serif;
}

#fb{
    font-family: sans-serif;
}

#fc{
    font-family: monospace;
}

#fd{
    font-family: cursive;
}

#fe{
    font-family: fantasy;
}

/* უმჯობესია მრავალსიტყვიანი შრიფტის სახელების "ბრჭყალებში" ჩასმა */

#ff {
    font-family:"Courier New", Monaco, monospace;
    }
    
/* font-weight თვისება აკონტროლებს ტექსტის სისქეს */
#thick{
    font-weight: 900;
}

/* თქვენ შეგიძლიათ გამოიყენოთ რიცხვითი მნიშვნელობები 100-დან (უწვრილესი) 900-მდე (ყველაზე სქელი) 100-იანი მატებით, რათა მიუთითოთ შრიფტის სისქე. 
 სისქის გარკვეულმა მნიშვნელობებმა, როგორიცაა 400 და 700, შეიძლება გამოყენებულ იქნას პირდაპირ მნიშვნელობებად: normal და bold.*/


/* ბმულები არის ქსელის არსი, რომელიც აკავშირებს ერთ გვერდს მეორესთან. 
 ისინი გადამწყვეტია ნავიგაციისთვის, მაგრამ ნაგულისხმევი ლურჯი ხაზგასმული სტილი ყოველთვის არ შეესაბამება ყველა დიზაინს.
 ბმული ნაგულისხმევად არის ლურჯი ფერის და ხაზგასმული.
 თქვენ შეგიძლიათ გააუქმოთ ეს ნაგულისხმევი სტილი CSS-ით ფერების, შრიფტებისა და დეკორატორების მორგებისთვის. 
 როდესაც მომხმარებლები ურთიერთობენ ბმულთან (ასევე სხვა ელემენტებთან), ის ცვლის მის მდგომარეობას. 
 თქვენ შეგიძლიათ მიუთითოთ ელემენტის სტატუსი ფსევდო სელექტორებით. */

/* ზოგადი ლინკის სტილის შეცვლა */
#a1:link{
    color: #ff0705;
    text-decoration: wavy underline;
    font-family: Comic Sans MS;

}

#a2:hover{
    color: burlywood;
    text-decoration: dashed underline;
    text-shadow: 5px 5px 5px #ff0705;
}

#a3:active{
    color: black;
    text-transform: uppercase;
    font-weight: 900;
    background-color: blue;
}

/* ჩვეულებრივ, ყველა ბმული ხაზგასმულია.
 თქვენ შეგიძლიათ წაშალოთ ხაზგასმული სტილი text-decoration თვისების none-ზე დაყენებით. */


/* ცხრილები მძლავრი ინსტრუმენტია მონაცემების სტრუქტურირებული და ორგანიზებული სახით წარმოდგენისთვის, 
 მაგრამ ისინი შეიძლება იყოს საკმაოდ მარტივი და შეიძლება არ ემთხვეოდეს თქვენი ვებსაიტის საერთო დიზაინს. 
 
table: <table>
table row: <tr>
data cell: <td>
header cell: <th>
 */

/* HTML ცხრილის გარეგნობა შეიძლება მნიშვნელოვნად გაუმჯობესდეს border თვისებით.
 border არის მოკლე და მარტივი გზა 3 სხვადასხვა ქვე-თვისების მითითებისთვის: 

border-width: 1px
border-style: solid
border-color: red

   ცხრილის გარშემო საზღვრის დასამატებლად გამოიყენეთ border თვისება <table>-ზე.
 ყველა უჯრედს საზღვრების დასამატებლად გამოიყენეთ border თვისება <th>-სა და <td>-ზე. 
 ერთადერთი აუცილებელი სასაზღვრო ქვესაკუთრება არის border-style. 
 თუ სიგანე არ არის მითითებული, ნაგულისხმევი მნიშვნელობა იქნება საშუალო (1px). 
 თუ ფერი არ არის მითითებული, ტექსტის ფერი გამოყენებული იქნება საზღვრებზე.
 ცხრილის უჯრედებს ჩვეულებრივ აქვთ ინტერვალი, რაც ორმაგ საზღვრებს აჩენს.
 ამ სივრცის ამოსაშლელად, შეგიძლიათ ცხრილის ელემენტებს მიანიჭოთ border-collapse  თვისება.  
 */
 
table {
    border-collapse: collapse;
}
th, td {
    border: 2px solid #909092;
}
th {
    background-color: #4A90E2; 
    color:white;
}

/* ცხრილს შეიძლება ჰქონდეს რამდენიმე ჩაშენებული(ბავშვი) სტრიქონი.
 ფსევდო სელექტორები ასევე შეიძლება გამოყენებულ იქნას ელემენტების დასამიზნებლად მათი რიგისა და პოზიციის მიხედვით.
 :nth-child(n) ფსევდო სელექტორი მიზნად ისახავს ბავშვის ელემენტებს მათი თანმიმდევრობის მიხედვით.
 */ 

tr:nth-child(3) {
    color: red;
    background-color: aquamarine;
 }

 tr:nth-child(5) {
    color: red;
    background-color: aquamarine;
 }
 
/* თქვენ ასევე შეგიძლიათ გამოიყენოთ :nth-child(even/odd) ფსევდო სელექტორი კენტი და ლუწი რიგების დასამიზნებლად 
 */

tr:nth-child(even){
    color: black;
    font-family: Comic Sans MS;
    background-color: #ff0705;
}


/* სტილირებული სიები აუმჯობესებს ვიზუალურ მიმზიდველობას, მომხმარებლის გამოცდილებას და ხელმისაწვდომობას. 
 სიის სტილის თვისება მოითხოვს 3 მნიშვნელობას. 
 ეს არის მოკლე და მარტივი გზა 3 სხვადასხვა ქვე-თვისების მითითებისთვის: type(ტიპი), position(პოზიცია) და image(გამოსახულება). 
 სიის სტილის ტიპის ქვესაკუთრება ცვლის მარკერს როგორც დაულაგებელი, ასევე დალაგებული სიებისთვის.  
 მოდით, ჯერ გადახედოთ დაულაგებელ სიებს: */

.trends {
    list-style-type: square;
    }
.most-watched {
    list-style-type: circle;
    }
.new-arrivals {
    list-style-type: disc;
    }
.classics {
    list-style-type: none;
    }
.heading {
    color: #494988;
    background-color: rgb(179, 149, 113);
    text-align: center;
}

/* ახლა კი, გადავხედუთ დალაგებულ სიებს. */

.top-selling {
    list-style-type: decimal-leading-zero;
}

.classic {
    list-style-type: decimal;
}

.biographies {
    list-style-type: lower-roman;
}
.fantasy {
    list-style-type: upper-roman;
}
#lvl1 , .lv2 {
    background-color:#FFA055;
    text-align: center;
}

/* თქვენ შეგიძლიათ მონიშნოთ დალაგებული სიის ელემენტები ანბანის ასოებით, მცირე ან დიდი. */
.upper-alpha {
    list-style-type: upper-alpha;
}

.lower-alpha {
    list-style-type: lower-alpha;
}

/*  მოდით შევხედოთ მარკერების პოზიციას. list-style-position თვისება იღებს ორ შესაძლო მნიშვნელობას: inside და outside. */

.outside {
    list-style-position: outside;
}

.inside {
    list-style-position: inside;
}

/* ტექნიკურად შესაძლებელია დალაგებული სიის სტილი ბულეტებით და დალაგებული სიის ნომრებით დალაგება, 
 მაგრამ ეს არ არის სემანტიკურად სწორი და შეიძლება დააბნიოს მომხმარებლები და საძიებო სისტემები. */

/* საბოლოო ქვე-თვისება, list-style-image, გაძლევთ საშუალებას დაამატოთ მორგებული სურათი მარკერად. */

#img {
    list-style-image:url(wave.png);
}

#img {
    font-size: 20px;
}



/* ფორმები გადამწყვეტ როლს თამაშობს მომხმარებელთა ურთიერთქმედებაში ბევრ ვებსაიტზე, მათ შორის შესვლაზე, გამოხმაურებასა და მონაცემთა შეყვანაში. 
 ჩვენ შეგვიძლია შევცვალოთ input-ები და  label-ები სელექტორების საშუალებით.*/

 